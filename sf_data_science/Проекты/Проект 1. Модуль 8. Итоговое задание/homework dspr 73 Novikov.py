import numpy as np

def binary_search(number: int = 1) -> int:

    """ За какое количество попыток алгоритм бинарного поиска находит загаданное число в диапазоне от 1 до 100

    Args:
        number: загаданное число 

    Returns:
        count: число попыток для нахождения загаданного числа 
    """
    possible_value,correction_value=100,50 # Задаем возможное значение загаданного \
        # числа и его корректировочное значение. Т.к. в условиях задания не было упора\
        # на универсальность решения, значения переменных числовые.
    count = 1 # Cчетчик числа попыток, равен 1, чтобы не возникало ошибки при значении \
        # загаданного числа 100.

    while possible_value!=number: # Пока возможное значение не сравняется с загаданным \
        # числом корректируем возможное значение.

        if possible_value>number: # Если возможное значение больше загаданного числа.
            count+=1 # Прибавляем счетчик попыток, т.к. следующая попытка сравнения \
                # может быть последней в цикле.
            possible_value-=correction_value # Корректируем возможное число \ 
                # уменьшением.
            correction_value=round(correction_value/2) # Уменьшаем корректировочное \
                # значение еще в два раза. Функция round неидеальна для этого, т.к. \
                # округляет не совсем ожидаемо, но для данной задачи подходит. \
                # Возможно, это приводит к увеличению числа попыток и следовательно \
                # перерасходу машинного времени. Данный вопрос требует дальнейшего \
                # изучения, если будет поставлена задача оптимизации данного параметра работы функции.

        if possible_value<number: # Аналогично предыдущему описанию, только  \
            # корректируем  возможное число увели
            count+=1
            possible_value+=correction_value
            correction_value=round(correction_value/2)

    return count


def score_game(binary_search) -> int:
    
    """За какое количество попыток в среднем за 1000 подходов угадывает наш алгоритм

    Args:
       binary_search(int): функция угадывания

    Returns:
       int: среднее количество попыток
    """
    count_ls = [] # список для сохранения количества попыток
    np.random.seed(1) # фиксируем сид для вопроизводимости
    random_array = np.random.randint(1, 101, size=(20)) # загадали список чисел

    for number in random_array:
        count_ls.append(binary_search(number))

    score = int(np.mean(count_ls)) # находим среднее количество попыток

    print(f'Ваш алгоритм угадывает число в среднем за: {score} попыток')
    return(score)

score_game(binary_search)